# AOI 솔더 페이스트 계측 프로젝트 설계문서

> **목적**: OMRON VT-S730/S720/S500 AOI 검사 데이터와 이미지를 활용하여,  
> OpenCV 기반으로 솔더 페이스트 영역을 정확히 추출·계측하는 프로그램 개발  
> **최종 목표**: 엣지 디바이스에서 API로 DB 접근 → 솔더 면적/높이 분포 계측  
> **작성일**: 2025-02-10

---

## 목차

1. [프로젝트 개요](#1-프로젝트-개요)
2. [도메인 지식: AOI 검사란?](#2-도메인-지식)
3. [보유 데이터 설명](#3-보유-데이터)
4. [핵심 기술 과제와 해결 전략](#4-핵심-기술-과제)
5. [단계별 구현 계획](#5-단계별-구현-계획)
6. [각 단계의 코드 설계](#6-각-단계의-코드-설계)
7. [포트폴리오 설명 가이드](#7-포트폴리오-설명-가이드)

---

## 1. 프로젝트 개요

### 한 줄 요약
> "AOI 장비가 촬영한 PCB 이미지에서, 솔더 페이스트 영역만 정확히 분리하여 면적을 mm² 단위로 계측하는 시스템"

### 왜 이 프로젝트가 필요한가?

AOI(자동 광학 검사) 장비는 PCB(인쇄회로기판) 위의 부품과 납땜 상태를 자동으로 검사합니다.
하지만 AOI 장비가 제공하는 크롭 이미지에는 다음과 같은 문제가 있습니다:

- **좌표가 부정확한 경우가 있음** (이상한 위치로 잘림)
- **리드선이 크기가 이상하게 나오는 경우가 있음**
- **솔더 페이스트 외의 영역(기판, 부품, 리드선)이 함께 포함됨**

따라서 "솔더 페이스트만 정확히 추출하여 계측"하려면 별도의 이미지 처리가 필요합니다.

### 시스템 구성도 (최종 목표)

```
[AOI 장비] → [DB/API] → [엣지 디바이스]
                              ↓
                     CSV 데이터 읽기
                     원본 이미지 로드
                              ↓
                     좌표로 ROI 크롭
                              ↓
                     솔더 페이스트 세그멘테이션
                              ↓
                     면적/높이 계측
                              ↓
                     결과 출력 (CSV + 시각화)
```

---

## 2. 도메인 지식

### 2.1 AOI 검사란?

AOI(Automated Optical Inspection)는 카메라로 PCB를 촬영하여 부품 실장 상태와
납땜 품질을 자동으로 검사하는 시스템입니다.

**검사 흐름** (OMRON VT-S730 기준):
1. 기판 반입 → 피듀셜 마크로 위치 보정
2. 검사 화면 단위로 촬영
3. 부품별로: 부품본체검사 → 전극검사 → 랜드검사 → 주변검사
4. 결과 판정 → 출력

### 2.2 검사 파라미터 4요소 (면접에서 설명할 핵심)

AOI 검사는 4가지 요소로 구성됩니다:

| 요소 | 설명 | 비유 |
|------|------|------|
| **윈도우** | 카메라 영상에서 검사할 영역 | "어디를 볼 것인가" |
| **검사영역** | 윈도우 내 실제 검사 범위 | "그 안에서 정확히 어느 부분을 볼 것인가" |
| **특징 파라미터** | 추출할 색상/형상 특징 | "무엇을 찾을 것인가" |
| **검사기준** | 합격/불량 임계값 | "얼마나 벗어나면 불량인가" |

### 2.3 카메라 스펙 (배율 계산에 필요)

OMRON VT-S730 스펙:
- 카메라: 4Mpixel (약 2048×2048) 또는 12Mpixel
- 렌즈: **텔레센트릭 렌즈** (매우 중요)
- FOV (시야): 30.00 × 30.72 mm
- 사시카메라: 4대 (경사각 촬영)
- 3D DLP 프로젝터: 높이 측정 최대 25mm

**텔레센트릭 렌즈가 중요한 이유 (면접 포인트)**:
- 일반 렌즈는 거리에 따라 크기가 달라짐 (원근감)
- 텔레센트릭 렌즈는 거리가 변해도 크기가 동일
- 즉, 기판이 약간 휘어도 부품 크기가 정확하게 측정됨
- 결론: **픽셀→mm 변환 비율이 일정함** (이것이 계측의 기초)

**픽셀-mm 변환 계산**:
```
4Mpixel 모드:
  해상도 ≒ 2048 × 2048 pixel
  FOV = 30.00 × 30.72 mm
  → 1 pixel ≒ 30.00/2048 ≒ 0.01465 mm ≒ 약 15 μm/pixel

12Mpixel 모드:
  → 1 pixel ≒ 약 7.5 μm/pixel

면적 변환:
  1 pixel² = 0.01465² ≒ 0.000215 mm² (4Mpixel 기준)
```

> **주의**: 위 계산은 FOV 전체를 촬영한 원본 이미지 기준입니다.
> CSV의 크롭 좌표가 원본 이미지의 픽셀 좌표이므로, 동일한 변환 비율을 적용할 수 있습니다.
> 실제 장비의 정확한 해상도는 CSV 데이터나 장비 설정에서 확인 필요합니다.

### 2.4 부품 분류 체계

OMRON AOI에서 부품은 크게 다음과 같이 분류됩니다:

| 분류 | 부품종 예시 | 솔더 특성 |
|------|------------|----------|
| **칩부품** | 칩저항, 칩콘덴서 (0402, 0603, 0805...) | 양 끝에 작은 필렛 |
| **리드부품** | QFP, SOP, 트랜지스터 | 리드선 옆에 필렛 |
| **BGA/CSP** | 볼 그리드 어레이 | 저면에 솔더볼 (직시 불가) |
| **삽입부품** | 커넥터, 전해콘덴서 | 관통홀 주변 필렛 |
| **어레이부품** | 저항어레이, QFN, SON | 다수의 작은 전극 |

**이 프로젝트에서 중요한 점**: 1000종이 넘는 부품이 있지만,
솔더 페이스트의 **형태 패턴은 10~15가지 카테고리**로 분류할 수 있습니다.

### 2.5 불량 코드 체계

주요 불량 코드 (CSV 데이터에 나올 수 있는 코드):

| 코드 | 불량명 | 설명 |
|------|--------|------|
| 0 | 정상 | 양품 |
| 130 | 결품 | 부품 미실장 |
| 131 | 부품다름 | 다른 부품 실장 |
| 132 | 극성위반 | 방향 반대로 실장 |
| 140 | 사이드돌출 | 전극 옆으로 돌출 |
| 152 | 솔더볼 | 솔더 볼 존재 |
| 153 | 솔더브리지 | 인접 랜드간 솔더 연결 |
| 160 | 젖음이상(랜드) | 솔더 젖음 불량 |
| 168 | 랜드노출 | 솔더 부족으로 랜드 노출 |
| 169 | 랜드이상 | 랜드에 이상 발생 |

---

## 3. 보유 데이터

### 3.1 데이터 구성

| # | 데이터 | 형식 | 내용 |
|---|--------|------|------|
| 1 | **AOI 검사 CSV** | .csv | 부품번호, 기판번호, 회로번호, 픽셀좌표 등 |
| 2 | **원본 이미지** | .jpg/.bmp | PCB 전체 또는 검사화면 단위 촬영 이미지 |
| 3 | **크롭 이미지** | .jpg/.bmp | AOI 좌표로 잘린 솔더 페이스트 부분 |

### 3.2 크롭 이미지의 문제점

AOI에서 제공한 크롭 이미지에는 아래와 같은 품질 문제가 있습니다:

```
[양호한 크롭]        [좌표 이상 크롭]      [크기 이상 크롭]
┌──────────┐        ┌──────────┐        ┌────────────────┐
│  솔더    │        │ 관계없는  │        │                │
│ ┌────┐  │        │  영역    │        │   리드선이      │
│ │패드│  │        │         │        │   비정상적으로   │
│ └────┘  │        │         │        │   크게 잘림      │
└──────────┘        └──────────┘        └────────────────┘
  → 정상              → 필터링 필요         → 보정 필요
```

### 3.3 확인 필요 사항 (Claude Code 시작 전)

- [ ] CSV 컬럼명과 샘플 데이터 (5행 정도)
- [ ] 원본 이미지 1장 (해상도 확인)
- [ ] 크롭 이미지 3~5장 (양호/불량/이상 케이스)
- [ ] 카메라 모드 (4Mpixel or 12Mpixel)
- [ ] 픽셀 좌표의 기준점 (좌상단? 중심?)

---

## 4. 핵심 기술 과제

### 과제 1: 픽셀 좌표 → 실제 크기 변환

**문제**: CSV의 좌표는 픽셀 단위인데, 실제 면적은 mm² 단위로 필요

**왜 이 방법을 쓰는가 (면접 설명용)**:
```
카메라가 찍은 이미지의 1픽셀이 실제로 몇 mm에 해당하는지 알면,
픽셀 수를 세는 것만으로 실제 면적을 계산할 수 있습니다.

텔레센트릭 렌즈 덕분에 이 비율이 이미지 전체에서 일정하므로,
단순한 곱셈으로 변환이 가능합니다.

면적(mm²) = 픽셀 수 × (μm/pixel)² × 10⁻⁶
```

**해결책**:
```python
# 변환 상수 (장비 스펙에서 확인 필요)
PIXEL_SIZE_UM = 15.0  # μm/pixel (4Mpixel 기준 예시)
PIXEL_SIZE_MM = PIXEL_SIZE_UM / 1000.0  # mm/pixel
PIXEL_AREA_MM2 = PIXEL_SIZE_MM ** 2  # mm²/pixel

# 면적 변환
area_pixels = 1500  # OpenCV로 세그멘테이션한 픽셀 수
area_mm2 = area_pixels * PIXEL_AREA_MM2
```

---

### 과제 2: 솔더 페이스트 영역 분리 (색상 세그멘테이션)

**문제**: 크롭 이미지에는 솔더 페이스트 외에 기판, 부품, 리드선이 함께 있음

**왜 HSV 색공간을 쓰는가 (면접 설명용)**:
```
RGB 색공간의 문제:
- 빨강(R), 초록(G), 파랑(B) 3개 채널이 모두 밝기에 영향을 받음
- 조명이 바뀌면 R, G, B 값이 모두 변함
- "이 색이 솔더인지 기판인지" 구분하기 어려움

HSV 색공간의 장점:
- H (Hue, 색상): 색의 종류 (빨강, 파랑, 초록...)
- S (Saturation, 채도): 색의 선명도
- V (Value, 명도): 밝기

→ 조명이 바뀌면 V(밝기)만 변하고, H(색상)는 거의 변하지 않음!
→ 솔더 페이스트는 특유의 은색/회색 계열 → H와 S로 분리 가능
```

**코드 예시**:
```python
import cv2
import numpy as np

# 1. 이미지 읽기
img = cv2.imread('crop_image.jpg')

# 2. HSV로 변환 (왜? 밝기와 색상을 분리하기 위해)
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# 3. 솔더 페이스트 색상 범위 지정
#    (실제 값은 샘플 이미지를 보고 조정해야 함)
lower = np.array([0, 0, 100])     # H_min, S_min, V_min
upper = np.array([180, 80, 255])  # H_max, S_max, V_max

# 4. 마스크 생성 (범위 안의 픽셀만 흰색으로)
mask = cv2.inRange(hsv, lower, upper)

# 5. 솔더 픽셀 수 세기
solder_pixels = cv2.countNonZero(mask)
```

---

### 과제 3: 조명 간섭 문제

**문제**: 같은 솔더라도 기판 위 위치에 따라 색이 달라 보임

**원인 (면접 설명용)**:
```
AOI 장비는 여러 각도의 LED 조명을 사용합니다.
키 큰 부품(전해콘덴서 등) 옆에 있는 작은 부품은:
- 그림자가 드리워져 어둡게 보임
- 인접 부품의 반사광이 비춰서 밝게 보임
- 금도금 패드는 글레어(눈부심)가 발생

결과적으로 동일한 솔더 페이스트가:
- 밝은 곳에서는 흰색에 가깝게
- 어두운 곳에서는 회색에 가깝게 보입니다

고정된 임계값으로는 둘 다 잡을 수 없습니다.
```

**해결 전략 (단계별)**:

```
Level 1: CLAHE (적응적 히스토그램 균등화) - 가장 먼저 시도
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
왜 쓰는가?
- 이미지를 작은 블록으로 나눠서, 각 블록마다 밝기를 균등화
- 어두운 부분은 밝게, 밝은 부분은 어둡게 자동 보정
- 조명이 불균일해도 전체적으로 균일한 대비를 얻을 수 있음

코드:
  clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
  enhanced = clahe.apply(gray_image)

Level 2: 적응적 이진화 (Adaptive Threshold)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
왜 쓰는가?
- 글로벌 임계값: 이미지 전체에 하나의 기준값 적용 → 조명 불균일에 취약
- 적응적 임계값: 각 픽셀 주변의 밝기를 기준으로 판단 → 조명 불균일에 강함

코드:
  adaptive = cv2.adaptiveThreshold(gray, 255,
      cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

Level 3: 모폴로지 연산 (노이즈 제거)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
왜 쓰는가?
- 세그멘테이션 후 작은 점들(노이즈)이 남을 수 있음
- Opening (침식→팽창): 작은 흰색 점 제거
- Closing (팽창→침식): 작은 구멍 메우기

코드:
  kernel = np.ones((3,3), np.uint8)
  cleaned = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
  cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_CLOSE, kernel)
```

---

### 과제 4: 1000종 부품 다대응

**문제**: 부품 종류마다 솔더 패턴이 다름

**해결 전략 (면접 설명용)**:
```
1000종을 개별 대응하면 → 파라미터 1000세트 = 비현실적

하지만 솔더 형태 기준으로 보면:
- 칩부품의 솔더 = 직사각형 양 끝에 작은 필렛
- 리드부품의 솔더 = 리드선 옆에 길쭉한 필렛
- BGA의 솔더 = 원형 볼

형태 패턴은 10~15개 → 카테고리별 파라미터 프리셋으로 대응 가능

추가로, CSV에 있는 부품 사이즈 정보를 활용하면:
- 랜드 크기에 비례하여 임계값을 자동 스케일링
- 절대값(0.5mm²) 대신 비율(랜드의 70%) 기준으로 판정
```

---

### 과제 5: 크롭 좌표 이상치 처리

**문제**: AOI가 제공한 좌표가 틀린 경우가 있음

**해결 전략**:
```
Step 1: 통계적 이상치 감지
- 동일 부품번호의 크롭 크기를 수집
- 평균 ± 2σ (표준편차) 벗어나면 이상치로 판정

Step 2: 이상치 재크롭
- 원본 이미지에서 CSV 좌표 주변을 넓게 크롭
- 랜드 패턴을 찾아서 정확한 위치로 재보정

Step 3: 결과 로깅
- 이상치로 판정된 항목을 별도 CSV로 출력
- 수동 확인 가능하도록
```

---

## 5. 단계별 구현 계획

### Phase 1: MVP (Week 1-2) - "1개 부품의 솔더 면적 계측"

```
목표: 가장 단순한 케이스를 동작시키기
입력: 양호한 크롭 이미지 1장
출력: 솔더 면적 (pixel, mm²)

구현할 것:
1. 이미지 읽기 (cv2.imread)
2. HSV 변환 (cv2.cvtColor)
3. 색상 범위 마스크 (cv2.inRange)
4. 노이즈 제거 (모폴로지)
5. 컨투어 추출 (cv2.findContours)
6. 면적 계산 (cv2.contourArea → mm² 변환)
7. 결과 시각화 (원본에 마스크 오버레이)

배울 수 있는 것:
- OpenCV 기본 파이프라인
- 색공간 변환의 원리
- 이진화와 컨투어의 관계
```

### Phase 2: CSV 연동 (Week 3-4) - "배치 처리"

```
목표: CSV를 읽어서 여러 이미지를 자동 처리
입력: CSV + 원본 이미지 폴더
출력: 결과 CSV (부품별 면적)

구현할 것:
1. CSV 파싱 (pandas)
2. 좌표로 원본에서 크롭 (numpy slicing)
3. 크롭 크기 이상치 감지 (통계)
4. Phase 1 로직을 함수화
5. 결과 CSV 출력
6. 간단한 통계 (평균, 표준편차, 히스토그램)

배울 수 있는 것:
- 데이터 파이프라인 설계
- 이상치 감지 기초
- 배치 처리 패턴
```

### Phase 3: 다부품종 대응 (Week 5-6) - "카테고리별 처리"

```
목표: 부품 종류에 따라 자동으로 파라미터 조정
입력: CSV (부품종 정보 포함) + 이미지
출력: 부품종별 계측 결과

구현할 것:
1. CSV의 부품종 → 카테고리 매핑
2. 카테고리별 HSV 범위 프리셋
3. 비율 기반 판정 로직
4. CLAHE 전처리 추가

배울 수 있는 것:
- 전략 패턴 (Strategy Pattern) 기초
- 적응적 전처리
```

### Phase 4: 조명 보정 & 대시보드 (Week 7-8) - "실용 수준"

```
목표: 조명 변화에 강건한 계측 + 결과 시각화
입력: 다양한 조건의 이미지
출력: 웹 대시보드 또는 리포트

구현할 것:
1. 적응적 이진화
2. 면적 분포 히스토그램
3. 양/불량 판정 시각화
4. 결과 리포트 자동 생성

배울 수 있는 것:
- 실제 산업 환경의 불확실성 대응
- 데이터 시각화
```

---

## 6. 각 단계의 코드 설계

### Phase 1: 핵심 함수 구조

```python
# === main.py ===

import cv2
import numpy as np

def load_image(path):
    """이미지를 읽어옵니다.
    
    왜 BGR인가?
    OpenCV는 역사적 이유로 RGB가 아닌 BGR 순서로 이미지를 읽습니다.
    HSV 변환 시 cv2.COLOR_BGR2HSV를 사용하는 이유입니다.
    """
    img = cv2.imread(path)
    if img is None:
        raise FileNotFoundError(f"이미지를 찾을 수 없음: {path}")
    return img


def preprocess(img):
    """전처리: 노이즈 제거 + 대비 향상
    
    왜 가우시안 블러를 쓰는가?
    - 카메라 센서의 랜덤 노이즈를 줄이기 위해
    - 커널 크기 (5,5)는 주변 5x5 픽셀의 가중 평균
    - 너무 크면 디테일이 사라지고, 너무 작으면 효과 없음
    """
    blurred = cv2.GaussianBlur(img, (5, 5), 0)
    return blurred


def segment_solder(img, lower_hsv, upper_hsv):
    """솔더 페이스트 영역을 추출합니다.
    
    처리 순서와 이유:
    1. BGR→HSV: 밝기와 색상을 분리하기 위해
    2. inRange: 지정한 HSV 범위 안의 픽셀만 추출
    3. Opening: 작은 노이즈 점 제거 (침식 후 팽창)
    4. Closing: 솔더 내부의 작은 구멍 메우기 (팽창 후 침식)
    """
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, lower_hsv, upper_hsv)
    
    kernel = np.ones((3, 3), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    
    return mask


def measure_area(mask, pixel_size_mm):
    """마스크에서 솔더 면적을 계측합니다.
    
    왜 contourArea를 쓰는가?
    - countNonZero: 전체 흰색 픽셀 수 (노이즈 포함)
    - findContours + contourArea: 연결된 영역별로 면적 계산 가능
      → 가장 큰 영역 = 솔더, 작은 영역 = 노이즈로 구분 가능
    """
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, 
                                    cv2.CHAIN_APPROX_SIMPLE)
    
    if not contours:
        return 0.0, 0, []
    
    # 면적이 큰 순으로 정렬
    contours = sorted(contours, key=cv2.contourArea, reverse=True)
    
    total_pixels = sum(cv2.contourArea(c) for c in contours)
    total_mm2 = total_pixels * (pixel_size_mm ** 2)
    
    return total_mm2, total_pixels, contours


def visualize(img, mask, contours):
    """결과를 시각화합니다.
    
    원본 이미지 위에 솔더 영역을 반투명 오버레이로 표시합니다.
    """
    overlay = img.copy()
    cv2.drawContours(overlay, contours, -1, (0, 255, 0), 2)
    
    # 반투명 마스크 오버레이
    colored_mask = np.zeros_like(img)
    colored_mask[mask > 0] = [0, 255, 0]  # 녹색
    result = cv2.addWeighted(img, 0.7, colored_mask, 0.3, 0)
    
    return result
```

### Phase 2: CSV 처리 구조

```python
# === csv_processor.py ===

import pandas as pd
import numpy as np

def load_csv(path):
    """AOI 검사 CSV를 읽어옵니다.
    
    컬럼 매핑은 실제 CSV 구조를 확인 후 조정 필요
    """
    df = pd.read_csv(path)
    return df


def extract_roi(original_img, x, y, w, h):
    """원본 이미지에서 ROI(관심영역)를 크롭합니다.
    
    왜 직접 크롭하는가?
    - AOI가 제공한 크롭 이미지는 좌표 오류가 있을 수 있음
    - 원본에서 직접 크롭하면 좌표를 보정할 수 있음
    
    numpy 슬라이싱:
    - img[y:y+h, x:x+w] → y행부터 h행, x열부터 w열 추출
    - 이미지는 [행(y), 열(x)] 순서 (수학의 x,y와 반대!)
    """
    roi = original_img[y:y+h, x:x+w]
    return roi


def detect_outlier_crops(df, size_col_w, size_col_h):
    """크롭 크기의 이상치를 감지합니다.
    
    왜 이 방법을 쓰는가?
    - 동일 부품번호는 비슷한 크기로 크롭되어야 함
    - 평균에서 2σ 이상 벗어나면 좌표 오류일 가능성 높음
    - IQR(사분위범위) 방법도 대안이 됨
    """
    # 부품번호별 그룹핑
    grouped = df.groupby('part_number')  # 실제 컬럼명으로 변경
    
    outliers = []
    for name, group in grouped:
        w_mean, w_std = group[size_col_w].mean(), group[size_col_w].std()
        h_mean, h_std = group[size_col_h].mean(), group[size_col_h].std()
        
        is_outlier = (
            (abs(group[size_col_w] - w_mean) > 2 * w_std) |
            (abs(group[size_col_h] - h_mean) > 2 * h_std)
        )
        outliers.extend(group[is_outlier].index.tolist())
    
    return outliers
```

### Phase 3: 카테고리별 파라미터

```python
# === category_config.py ===

# 부품 카테고리별 HSV 범위 프리셋
# (실제 값은 샘플 이미지를 분석하여 조정 필요)

CATEGORY_PARAMS = {
    'chip': {
        'description': '칩부품 (저항, 콘덴서 등)',
        'lower_hsv': [0, 0, 100],
        'upper_hsv': [180, 80, 255],
        'min_area_ratio': 0.3,   # 랜드 면적 대비 최소 솔더 비율
        'max_area_ratio': 1.5,   # 랜드 면적 대비 최대 솔더 비율
    },
    'lead': {
        'description': '리드부품 (QFP, SOP 등)',
        'lower_hsv': [0, 0, 120],
        'upper_hsv': [180, 60, 255],
        'min_area_ratio': 0.2,
        'max_area_ratio': 1.2,
    },
    'bga': {
        'description': 'BGA/CSP (직시 불가, 주변 검사만)',
        'lower_hsv': [0, 0, 80],
        'upper_hsv': [180, 100, 255],
        'min_area_ratio': 0.5,
        'max_area_ratio': 1.0,
    },
    # ... 추가 카테고리
}

def get_params(part_type):
    """부품종에 해당하는 카테고리 파라미터를 반환합니다.
    
    왜 비율(ratio) 기준인가?
    - 절대값 기준: "0.5mm² 이하면 불량" → 큰 부품에는 너무 엄격, 작은 부품에는 너무 관대
    - 비율 기준: "랜드의 30% 미만이면 불량" → 부품 크기에 무관하게 적용 가능
    """
    # 부품종 → 카테고리 매핑 (실제로는 더 정교한 매핑 필요)
    if 'chip' in part_type.lower() or 'resistor' in part_type.lower():
        return CATEGORY_PARAMS['chip']
    elif 'qfp' in part_type.lower() or 'sop' in part_type.lower():
        return CATEGORY_PARAMS['lead']
    elif 'bga' in part_type.lower() or 'csp' in part_type.lower():
        return CATEGORY_PARAMS['bga']
    else:
        return CATEGORY_PARAMS['chip']  # 기본값
```

---

## 7. 포트폴리오 설명 가이드

### 면접에서 이 프로젝트를 설명하는 구조

**Q: 이 프로젝트가 무엇인가요?**
```
"PCB 기판의 품질을 검사하는 AOI 장비의 데이터를 활용하여,
솔더 페이스트의 면적을 자동으로 계측하는 시스템을 만들었습니다.

기존에는 AOI 장비의 판정 결과(양품/불량)만 활용했지만,
제 시스템은 솔더 영역을 직접 추출하여 정량적인 면적 데이터를 산출합니다.
이를 통해 '불량은 아니지만 면적이 줄어드는 추세'와 같은
공정 변화를 조기에 감지할 수 있습니다."
```

**Q: 왜 HSV 색공간을 사용했나요?**
```
"RGB 색공간에서는 조명 변화가 R, G, B 세 채널 모두에 영향을 줍니다.
HSV로 변환하면 밝기(V)와 색상(H)이 분리되므로,
조명이 변해도 색상 기반의 세그멘테이션이 안정적입니다.

AOI 장비 내부에서도 유사한 원리로 Color Highlight™ 기술을 사용하여
다색 조명에서 3D 형상을 복원합니다."
```

**Q: 1000종 부품을 어떻게 대응하나요?**
```
"솔더 페이스트의 형태를 기준으로 10~15개 카테고리로 그루핑했습니다.
각 카테고리에 HSV 범위와 판정 기준의 프리셋을 만들고,
CSV의 부품종 정보를 기반으로 자동 매칭합니다.

또한 절대값(mm²) 대신 랜드 면적 대비 비율(%)로 판정하여,
부품 크기에 무관하게 동일한 로직을 적용할 수 있습니다."
```

**Q: 조명 문제는 어떻게 해결했나요?**
```
"세 단계로 대응했습니다:
1. CLAHE로 지역적 대비 보정 (조명 불균일 완화)
2. 적응적 이진화로 지역적 임계값 적용
3. 모폴로지 연산으로 노이즈 제거

이는 실제 AOI 장비에서도 유사한 전처리를 수행하는데,
OMRON의 경우 Color Highlight 기술과 다각도 조명으로 대응하고 있습니다."
```

**Q: 어려웠던 점은?**
```
"가장 어려웠던 것은 AOI 크롭 좌표의 부정확함이었습니다.
동일 부품이라도 좌표가 틀려서 엉뚱한 위치가 잘리는 경우가 있었습니다.

이를 해결하기 위해:
1. 동일 부품번호의 크롭 크기 통계로 이상치를 자동 감지하고
2. 이상치인 경우 원본 이미지에서 직접 재크롭하는 로직을 구현했습니다."
```

---

## 부록: 용어집

| 용어 | 설명 |
|------|------|
| AOI | Automated Optical Inspection, 자동 광학 검사 |
| PCB | Printed Circuit Board, 인쇄회로기판 |
| SMT | Surface Mount Technology, 표면실장기술 |
| 솔더 페이스트 | 부품을 기판에 접합하는 납땜 재료 |
| 필렛 (Fillet) | 솔더가 전극과 랜드를 연결하는 경사면 |
| 랜드 (Land) | PCB 위의 구리 패드 (부품이 올라가는 자리) |
| 피듀셜 마크 | 기판 위치 보정을 위한 기준 마크 |
| FOV | Field of View, 카메라 시야 범위 |
| 텔레센트릭 렌즈 | 거리에 무관하게 배율이 일정한 특수 렌즈 |
| HSV | Hue(색상), Saturation(채도), Value(명도) 색공간 |
| CLAHE | Contrast Limited Adaptive Histogram Equalization |
| ROI | Region of Interest, 관심 영역 |
| 모폴로지 | 이미지의 형태학적 연산 (침식, 팽창 등) |
| 컨투어 | 이미지에서 동일 밝기/색상의 연결된 경계선 |
| 세그멘테이션 | 이미지에서 특정 영역을 분리하는 것 |
| 이진화 | 이미지를 흑백(0/255)으로 변환하는 것 |
| 임계값 | 이진화 시 흑/백을 구분하는 기준값 |

---

> **이 문서는 Claude Code 세션에서 프로젝트 컨텍스트로 사용됩니다.**  
> 실제 CSV 샘플과 이미지를 확인한 후, 각 Phase의 구체적인 파라미터를 조정합니다.
